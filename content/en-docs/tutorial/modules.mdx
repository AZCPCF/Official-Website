---
title: Modules
weight: 8
---

# Modules

Cyrus features a **powerful module system** with **incremental compilation** and a **strong module cache**. Modules allow code organization, reusability, and proper scoping.

<br />

## Module Files

In Cyrus, **files are considered modules**.

Module files must:
  - Use **snake_case** names
  - Have the `.cyr` extension
- Example: `user_utils.cyr` defines a module named `user_utils`.

<br />

## Importing Modules

Modules can be imported into other files **beside the entry (main) file**.

```cyrus
import sample;
```

- Only publicly exported symbols from a module are accessible.
- After importing, access symbols with the module name:

```cyrus
sample::some_func();
```

<br />

## Importing Single Symbols

You can import only a single symbol instead of the whole module:

```cyrus
import sample{some_func};

some_func(); // direct usage without module prefix
```

Note: If you import a symbol individually, you cannot import the whole module again in the same file.

<br />

## Importing Multiple Modules

Cyrus supports grouped imports as syntactic sugar:

```cyrus
import (
    foo{greeting_func},
    bar
);
```

<br />

## Renaming Imported Symbols

Cyrus allows renaming symbols when importing to avoid conflicts or for clarity:

```cyrus
import std::libc{my_func: printf}; // rename printf to my_func
import my_libc: std::libc;         // rename entire module
```

<br />

## Compiler Module Paths

You can tell the Cyrus compiler where to search for modules using CLI flags:

```text
--sources=<directory> // Add directories to search for imported modules
--build-dir <PATH>    // Directory where build artifacts will be stored
--base-path <PATH>    // Base path for running the command
```

- **sources** allows you to include multiple module directories.
- **build-dir** is used for caching compiled modules and incremental builds.
- **base-path** sets a reference path for resolving relative imports.

<br />

## Local Structs

In Cyrus, structs can also be declared **locally inside functions**. This is useful when the type is only relevant to that function and should not pollute the global scope.

```cyrus
func main() {
    struct User {
        name: char*;
        age: uint;
    }

    #user = User { name: "Cyrus", age: 2500 }; 
    libc::printf("%s is %d years old.\n", user.name, user.age);
}
```

<br />

## Unnamed Structs

Unnamed structs are struct values declared inline without defining a named type. They are useful for quick, one-off configurations or temporary data holders.

```cyrus
func main() {
    #state = struct {
        name = "Cyrus",
        counter = 0,
    };

    config.name; 
    state.counter += 1;
}
```

Field types are inferred automatically.

<br />

## Typed Unnamed Struct

You can also specify field types explicitly:

```cyrus
#state = struct {
    name: char* = "Cyrus",
    counter: int = 0,
};
```

Note: Unnamed structs cannot define methods.

<br />

## Global Unnamed Structs

Unnamed structs are not limited to local scope. They can also be declared globally and accessed across functions (if marked public).

```cyrus
public config = const struct {
    host = "127.0.0.1",
    port = 8080
};

func main() {
    printf("host: %s\n", config.host);
    printf("port: %d\n", config.port);
}
```